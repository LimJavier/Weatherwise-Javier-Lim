Tool: ChatGPT
Date: 9-10-2025
Title: Conversations about weather data retrieval
------------------------------------------------------------------------------------------------------------------
Me: I need to write a function to retrieve weather data for a specific location.
AI: Got it üëç
Here‚Äôs a clear, well-structured example of a Python function that retrieves weather data for a given location using a public API (like OpenWeatherMap):

‚úÖ Example: Fetch Weather Data Function
import requests

def fetch_weather_data(location, units="metric"):
    """
    Fetch current weather data for a specific location using the OpenWeatherMap API.
    
    Args:
        location (str): City name or location (e.g., 'Perth' or 'Sydney,AU')
        units (str): Unit system for temperature ‚Äî 'metric' (Celsius) or 'imperial' (Fahrenheit)
        
    Returns:
        dict: A dictionary containing weather details such as temperature, humidity, and description.
        
    Raises:
        ConnectionError: If unable to connect to the weather API.
        ValueError: If the API returns an invalid location or missing data.
    """
    # Replace with your actual API key
    API_KEY = "YOUR_API_KEY"
    BASE_URL = "https://api.openweathermap.org/data/2.5/weather"

    try:
        response = requests.get(BASE_URL, params={
            "q": location,
            "appid": API_KEY,
            "units": units
        })
        response.raise_for_status()  # Raises HTTPError for bad responses

        data = response.json()

        # Check for invalid responses
        if data.get("cod") != 200:
            raise ValueError(f"Error from API: {data.get('message', 'Unknown error')}")

        # Extract key weather info
        weather_info = {
            "location": data["name"],
            "temperature": data["main"]["temp"],
            "humidity": data["main"]["humidity"],
            "description": data["weather"][0]["description"].capitalize(),
        }

        return weather_info

    except requests.exceptions.RequestException as e:
        raise ConnectionError(f"Network or connection error: {e}")

    except KeyError:
        raise ValueError("Unexpected data format from API.")

üß† Example Usage
try:
    result = fetch_weather_data("Perth")
    print(result)
except Exception as e:
    print(f"Error: {e}")

Output example:
{
  'location': 'Perth',
  'temperature': 26.4,
  'humidity': 54,
  'description': 'Clear sky'
}

Me: Thanks for the initial code suggestions. However, can you improve the function by including: 1. Error handling for poor responses, such as invalid location and parameters 2. Add retry attempts if the first request fails due to connection error 3. Provide a summary of the weather output for easy understanding 4. Document and structure the returned outputs with explanations 5. Include a forecast_days parameter to allow the user to forecast the weather for up to the next five days, and ensure it handles invalid values
AI: Perfect üòÑ ‚Äî I‚Äôll create a more robust, documented function for retrieving weather data that meets all your requirements.

We‚Äôll use OpenWeatherMap‚Äôs Current Weather API for current weather and 5-day/3-hour forecast API for forecasts.
We‚Äôll also add error handling, retry logic, summarized output, and a forecast_days parameter.

üìú Improved Weather Function
import requests
import time

def fetch_weather_data(location, units="metric", forecast_days=0, max_retries=3):
    """
    Retrieve weather data for a specified location with optional forecast days.
    
    Args:
        location (str): City name (e.g., "Perth") or "City,Country" (e.g., "Perth,AU").
        units (str): "metric" (¬∞C) or "imperial" (¬∞F). Default is "metric".
        forecast_days (int): Number of days to forecast (0 = current weather only). Max = 5.
        max_retries (int): Number of retry attempts for connection errors. Default = 3.
        
    Returns:
        dict: Structured weather information including:
            - current: Current weather data (temperature, humidity, description, etc.)
            - forecast: List of daily forecasts (if forecast_days > 0)
            - summary: Human-readable weather summary
            - location: Verified location name and country
        
    Raises:
        ValueError: Invalid parameters or location.
        ConnectionError: Unable to connect after retries.
    """

    API_KEY = "YOUR_API_KEY"  # Replace with your actual OpenWeatherMap API key
    CURRENT_URL = "https://api.openweathermap.org/data/2.5/weather"
    FORECAST_URL = "https://api.openweathermap.org/data/2.5/forecast"

    def request_with_retries(url, params, retries=max_retries):
        """Helper: Retry request if connection fails."""
        attempt = 0
        while attempt < retries:
            try:
                response = requests.get(url, params=params, timeout=10)
                response.raise_for_status()
                return response.json()
            except requests.exceptions.RequestException as e:
                attempt += 1
                print(f"[Warning] Attempt {attempt} failed: {e}. Retrying...")
                time.sleep(2)  # Wait before retry
        raise ConnectionError(f"Failed to connect after {retries} attempts.")

    # Validate forecast_days parameter
    if not isinstance(forecast_days, int) or forecast_days < 0 or forecast_days > 5:
        raise ValueError("forecast_days must be an integer between 0 and 5.")

    # Fetch current weather
    params = {"q": location, "appid": API_KEY, "units": units}
    current_data = request_with_retries(CURRENT_URL, params)

    if current_data.get("cod") != 200:
        raise ValueError(f"Error from API: {current_data.get('message', 'Unknown error')}")

    current_weather = {
        "temperature": current_data["main"]["temp"],
        "humidity": current_data["main"]["humidity"],
        "description": current_data["weather"][0]["description"].capitalize(),
        "wind_speed": current_data["wind"]["speed"],
    }

    weather_output = {
        "location": f"{current_data.get('name')}, {current_data.get('sys', {}).get('country')}",
        "current": current_weather,
        "forecast": [],
        "summary": f"Current weather in {current_data.get('name')}: {current_weather['description']}, "
                   f"{current_weather['temperature']}¬∞ with {current_weather['humidity']}% humidity."
    }

    # Fetch forecast if requested
    if forecast_days > 0:
        forecast_params = {"q": location, "appid": API_KEY, "units": units}
        forecast_data = request_with_retries(FORECAST_URL, forecast_params)

        if forecast_data.get("cod") != "200":
            raise ValueError(f"Error from API: {forecast_data.get('message', 'Unknown error')}")

        daily_forecast = {}
        for entry in forecast_data["list"]:
            date = entry["dt_txt"].split(" ")[0]
            if date not in daily_forecast:
                daily_forecast[date] = {
                    "temperature_min": entry["main"]["temp_min"],
                    "temperature_max": entry["main"]["temp_max"],
                    "description": entry["weather"][0]["description"].capitalize()
                }
            else:
                daily_forecast[date]["temperature_min"] = min(daily_forecast[date]["temperature_min"], entry["main"]["temp_min"])
                daily_forecast[date]["temperature_max"] = max(daily_forecast[date]["temperature_max"], entry["main"]["temp_max"])

        sorted_dates = sorted(daily_forecast.keys())
        weather_output["forecast"] = [
            {"date": d, **daily_forecast[d]} for d in sorted_dates[:forecast_days]
        ]

        weather_output["summary"] += f" Forecast available for next {forecast_days} day(s)."

    return weather_output
üîπ Example Usage
try:
    weather = fetch_weather_data("Perth", units="metric", forecast_days=3)
    print(weather["summary"])
    print("Current:", weather["current"])
    if weather["forecast"]:
        print("Forecast:")
        for day in weather["forecast"]:
            print(day)
except Exception as e:
    print(f"Error: {e}")

üìå What This Function Does

‚úÖ Handles invalid location and parameters (ValueError raised).

‚úÖ Retries requests if connection fails (max_retries times).

‚úÖ Provides structured output with current, forecast, summary, and location.

‚úÖ Supports forecast_days up to 5.

‚úÖ Clear documentation for maintainability.

Me: The function currently does not display error messages for invalid locations or API keys. Can you improve the error handling so users receive a clear and specific message indicating whether the location or API key is invalid?

AI: Perfect üëç ‚Äî I understand exactly what you want.

Right now, the function catches general API errors but doesn‚Äôt clearly differentiate between an invalid location and an invalid API key.
We can improve this by explicitly checking the API‚Äôs error codes and messages and returning a user-friendly explanation.

Here‚Äôs the improved function with enhanced error handling:
üìú Improved Weather Function with Detailed Error Handling
import requests
import time

def fetch_weather_data(location, units="metric", forecast_days=0, max_retries=3):
    """
    Retrieve weather data for a specified location with optional forecast days.
    
    Args:
        location (str): City name (e.g., "Perth") or "City,Country" (e.g., "Perth,AU").
        units (str): "metric" (¬∞C) or "imperial" (¬∞F). Default is "metric".
        forecast_days (int): Number of days to forecast (0 = current weather only). Max = 5.
        max_retries (int): Number of retry attempts for connection errors. Default = 3.
        
    Returns:
        dict: Structured weather information including:
            - location: Verified location name and country
            - current: Current weather data (temperature, humidity, description, wind speed)
            - forecast: List of daily forecasts (if forecast_days > 0)
            - summary: Human-readable weather summary
        
    Raises:
        ValueError: Invalid parameters, location, or API key.
        ConnectionError: Unable to connect after retries.
    """

    API_KEY = "YOUR_API_KEY"  # Replace with your OpenWeatherMap API key
    CURRENT_URL = "https://api.openweathermap.org/data/2.5/weather"
    FORECAST_URL = "https://api.openweathermap.org/data/2.5/forecast"

    def request_with_retries(url, params, retries=max_retries):
        """Helper: Retry request if connection fails."""
        attempt = 0
        while attempt < retries:
            try:
                response = requests.get(url, params=params, timeout=10)
                if response.status_code == 401:
                    raise ValueError("Invalid API key. Please check your OpenWeatherMap API key.")
                if response.status_code == 404:
                    raise ValueError(f"Location '{location}' not found. Please check the location name.")
                response.raise_for_status()
                return response.json()
            except requests.exceptions.RequestException as e:
                attempt += 1
                if attempt >= retries:
                    raise ConnectionError(f"Failed to connect after {retries} attempts: {e}")
                print(f"[Warning] Attempt {attempt} failed: {e}. Retrying...")
                time.sleep(2)

    # Validate forecast_days parameter
    if not isinstance(forecast_days, int) or forecast_days < 0 or forecast_days > 5:
        raise ValueError("forecast_days must be an integer between 0 and 5.")

    # Fetch current weather
    params = {"q": location, "appid": API_KEY, "units": units}
    current_data = request_with_retries(CURRENT_URL, params)

    if current_data.get("cod") != 200:
        error_message = current_data.get("message", "Unknown error")
        if "invalid api key" in error_message.lower():
            raise ValueError("Invalid API key. Please check your API key in OpenWeatherMap.")
        elif "city not found" in error_message.lower():
            raise ValueError(f"Location '{location}' not found. Please check the spelling.")
        else:
            raise ValueError(f"Error from API: {error_message}")

    current_weather = {
        "temperature": current_data["main"]["temp"],
        "humidity": current_data["main"]["humidity"],
        "description": current_data["weather"][0]["description"].capitalize(),
        "wind_speed": current_data["wind"]["speed"],
    }

    weather_output = {
        "location": f"{current_data.get('name')}, {current_data.get('sys', {}).get('country')}",
        "current": current_weather,
        "forecast": [],
        "summary": f"Current weather in {current_data.get('name')}: {current_weather['description']}, "
                   f"{current_weather['temperature']}¬∞ with {current_weather['humidity']}% humidity."
    }

    # Fetch forecast if requested
    if forecast_days > 0:
        forecast_params = {"q": location, "appid": API_KEY, "units": units}
        forecast_data = request_with_retries(FORECAST_URL, forecast_params)

        if forecast_data.get("cod") != "200":
            error_message = forecast_data.get("message", "Unknown error")
            raise ValueError(f"Forecast error: {error_message}")

        daily_forecast = {}
        for entry in forecast_data["list"]:
            date = entry["dt_txt"].split(" ")[0]
            if date not in daily_forecast:
                daily_forecast[date] = {
                    "temperature_min": entry["main"]["temp_min"],
                    "temperature_max": entry["main"]["temp_max"],
                    "description": entry["weather"][0]["description"].capitalize()
                }
            else:
                daily_forecast[date]["temperature_min"] = min(daily_forecast[date]["temperature_min"], entry["main"]["temp_min"])
                daily_forecast[date]["temperature_max"] = max(daily_forecast[date]["temperature_max"], entry["main"]["temp_max"])

        sorted_dates = sorted(daily_forecast.keys())
        weather_output["forecast"] = [
            {"date": d, **daily_forecast[d]} for d in sorted_dates[:forecast_days]
        ]

        weather_output["summary"] += f" Forecast available for next {forecast_days} day(s)."

    return weather_output
üîπ Example Usage with Error Messages
try:
    weather = fetch_weather_data("InvalidCityName", units="metric", forecast_days=2)
    print(weather["summary"])
    print("Current:", weather["current"])
    if weather["forecast"]:
        print("Forecast:")
        for day in weather["forecast"]:
            print(day)
except ValueError as ve:
    print(f"[ValueError] {ve}")
except ConnectionError as ce:
    print(f"[ConnectionError] {ce}")
except Exception as e:
    print(f"[Error] {e}")

üîπ What‚Äôs Improved

1. Invalid API key detection ‚Äî gives clear "Invalid API key" error.

2. Invalid location detection ‚Äî gives clear "Location not found" error.

3. Connection retries ‚Äî with warning and retry mechanism.

4. Detailed error messages ‚Äî differentiates between API key, location, or other issues.

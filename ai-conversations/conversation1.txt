Tool: ChatGPT
Date: 9-10-2025
Title: Conversations about weather data retrieval
------------------------------------------------------------------------------------------------------------------
Me: I need to write a function to retrieve weather data for a specific location.
AI: Got it ðŸ‘
Hereâ€™s a clear, well-structured example of a Python function that retrieves weather data for a given location using a public API (like OpenWeatherMap):

âœ… Example: Fetch Weather Data Function
import requests

def fetch_weather_data(location, units="metric"):
    """
    Fetch current weather data for a specific location using the OpenWeatherMap API.
    
    Args:
        location (str): City name or location (e.g., 'Perth' or 'Sydney,AU')
        units (str): Unit system for temperature â€” 'metric' (Celsius) or 'imperial' (Fahrenheit)
        
    Returns:
        dict: A dictionary containing weather details such as temperature, humidity, and description.
        
    Raises:
        ConnectionError: If unable to connect to the weather API.
        ValueError: If the API returns an invalid location or missing data.
    """
    # Replace with your actual API key
    API_KEY = "YOUR_API_KEY"
    BASE_URL = "https://api.openweathermap.org/data/2.5/weather"

    try:
        response = requests.get(BASE_URL, params={
            "q": location,
            "appid": API_KEY,
            "units": units
        })
        response.raise_for_status()  # Raises HTTPError for bad responses

        data = response.json()

        # Check for invalid responses
        if data.get("cod") != 200:
            raise ValueError(f"Error from API: {data.get('message', 'Unknown error')}")

        # Extract key weather info
        weather_info = {
            "location": data["name"],
            "temperature": data["main"]["temp"],
            "humidity": data["main"]["humidity"],
            "description": data["weather"][0]["description"].capitalize(),
        }

        return weather_info

    except requests.exceptions.RequestException as e:
        raise ConnectionError(f"Network or connection error: {e}")

    except KeyError:
        raise ValueError("Unexpected data format from API.")

ðŸ§  Example Usage
try:
    result = fetch_weather_data("Perth")
    print(result)
except Exception as e:
    print(f"Error: {e}")

Output example:
{
  'location': 'Perth',
  'temperature': 26.4,
  'humidity': 54,
  'description': 'Clear sky'
}

Me: Thanks for the initial code suggestions. However, can you improve the function by including: 1. Error handling for poor responses, such as invalid location and parameters 2. Add retry attempts if the first request fails due to connection error 3. Provide a summary of the weather output for easy understanding 4. Document and structure the returned outputs with explanations 5. Include a forecast_days parameter to allow the user to forecast the weather for up to the next five days, and ensure it handles invalid values
AI: Perfect ðŸ˜„ â€” Iâ€™ll create a more robust, documented function for retrieving weather data that meets all your requirements.

Weâ€™ll use OpenWeatherMapâ€™s Current Weather API for current weather and 5-day/3-hour forecast API for forecasts.
Weâ€™ll also add error handling, retry logic, summarized output, and a forecast_days parameter.

ðŸ“œ Improved Weather Function
import requests
import time

def fetch_weather_data(location, units="metric", forecast_days=0, max_retries=3):
    """
    Retrieve weather data for a specified location with optional forecast days.
    
    Args:
        location (str): City name (e.g., "Perth") or "City,Country" (e.g., "Perth,AU").
        units (str): "metric" (Â°C) or "imperial" (Â°F). Default is "metric".
        forecast_days (int): Number of days to forecast (0 = current weather only). Max = 5.
        max_retries (int): Number of retry attempts for connection errors. Default = 3.
        
    Returns:
        dict: Structured weather information including:
            - current: Current weather data (temperature, humidity, description, etc.)
            - forecast: List of daily forecasts (if forecast_days > 0)
            - summary: Human-readable weather summary
            - location: Verified location name and country
        
    Raises:
        ValueError: Invalid parameters or location.
        ConnectionError: Unable to connect after retries.
    """

    API_KEY = "YOUR_API_KEY"  # Replace with your actual OpenWeatherMap API key
    CURRENT_URL = "https://api.openweathermap.org/data/2.5/weather"
    FORECAST_URL = "https://api.openweathermap.org/data/2.5/forecast"

    def request_with_retries(url, params, retries=max_retries):
        """Helper: Retry request if connection fails."""
        attempt = 0
        while attempt < retries:
            try:
                response = requests.get(url, params=params, timeout=10)
                response.raise_for_status()
                return response.json()
            except requests.exceptions.RequestException as e:
                attempt += 1
                print(f"[Warning] Attempt {attempt} failed: {e}. Retrying...")
                time.sleep(2)  # Wait before retry
        raise ConnectionError(f"Failed to connect after {retries} attempts.")

    # Validate forecast_days parameter
    if not isinstance(forecast_days, int) or forecast_days < 0 or forecast_days > 5:
        raise ValueError("forecast_days must be an integer between 0 and 5.")

    # Fetch current weather
    params = {"q": location, "appid": API_KEY, "units": units}
    current_data = request_with_retries(CURRENT_URL, params)

    if current_data.get("cod") != 200:
        raise ValueError(f"Error from API: {current_data.get('message', 'Unknown error')}")

    current_weather = {
        "temperature": current_data["main"]["temp"],
        "humidity": current_data["main"]["humidity"],
        "description": current_data["weather"][0]["description"].capitalize(),
        "wind_speed": current_data["wind"]["speed"],
    }

    weather_output = {
        "location": f"{current_data.get('name')}, {current_data.get('sys', {}).get('country')}",
        "current": current_weather,
        "forecast": [],
        "summary": f"Current weather in {current_data.get('name')}: {current_weather['description']}, "
                   f"{current_weather['temperature']}Â° with {current_weather['humidity']}% humidity."
    }

    # Fetch forecast if requested
    if forecast_days > 0:
        forecast_params = {"q": location, "appid": API_KEY, "units": units}
        forecast_data = request_with_retries(FORECAST_URL, forecast_params)

        if forecast_data.get("cod") != "200":
            raise ValueError(f"Error from API: {forecast_data.get('message', 'Unknown error')}")

        daily_forecast = {}
        for entry in forecast_data["list"]:
            date = entry["dt_txt"].split(" ")[0]
            if date not in daily_forecast:
                daily_forecast[date] = {
                    "temperature_min": entry["main"]["temp_min"],
                    "temperature_max": entry["main"]["temp_max"],
                    "description": entry["weather"][0]["description"].capitalize()
                }
            else:
                daily_forecast[date]["temperature_min"] = min(daily_forecast[date]["temperature_min"], entry["main"]["temp_min"])
                daily_forecast[date]["temperature_max"] = max(daily_forecast[date]["temperature_max"], entry["main"]["temp_max"])

        sorted_dates = sorted(daily_forecast.keys())
        weather_output["forecast"] = [
            {"date": d, **daily_forecast[d]} for d in sorted_dates[:forecast_days]
        ]

        weather_output["summary"] += f" Forecast available for next {forecast_days} day(s)."

    return weather_output
ðŸ”¹ Example Usage
try:
    weather = fetch_weather_data("Perth", units="metric", forecast_days=3)
    print(weather["summary"])
    print("Current:", weather["current"])
    if weather["forecast"]:
        print("Forecast:")
        for day in weather["forecast"]:
            print(day)
except Exception as e:
    print(f"Error: {e}")

ðŸ“Œ What This Function Does

âœ… Handles invalid location and parameters (ValueError raised).

âœ… Retries requests if connection fails (max_retries times).

âœ… Provides structured output with current, forecast, summary, and location.

âœ… Supports forecast_days up to 5.

âœ… Clear documentation for maintainability.

Me: The function currently does not display error messages for invalid locations or API keys. Can you improve the error handling so users receive a clear and specific message indicating whether the location or API key is invalid?

AI: Perfect ðŸ‘ â€” I understand exactly what you want.

Right now, the function catches general API errors but doesnâ€™t clearly differentiate between an invalid location and an invalid API key.
We can improve this by explicitly checking the APIâ€™s error codes and messages and returning a user-friendly explanation.

Hereâ€™s the improved function with enhanced error handling:
ðŸ“œ Improved Weather Function with Detailed Error Handling
import requests
import time

def fetch_weather_data(location, units="metric", forecast_days=0, max_retries=3):
    """
    Retrieve weather data for a specified location with optional forecast days.
    
    Args:
        location (str): City name (e.g., "Perth") or "City,Country" (e.g., "Perth,AU").
        units (str): "metric" (Â°C) or "imperial" (Â°F). Default is "metric".
        forecast_days (int): Number of days to forecast (0 = current weather only). Max = 5.
        max_retries (int): Number of retry attempts for connection errors. Default = 3.
        
    Returns:
        dict: Structured weather information including:
            - location: Verified location name and country
            - current: Current weather data (temperature, humidity, description, wind speed)
            - forecast: List of daily forecasts (if forecast_days > 0)
            - summary: Human-readable weather summary
        
    Raises:
        ValueError: Invalid parameters, location, or API key.
        ConnectionError: Unable to connect after retries.
    """

    API_KEY = "YOUR_API_KEY"  # Replace with your OpenWeatherMap API key
    CURRENT_URL = "https://api.openweathermap.org/data/2.5/weather"
    FORECAST_URL = "https://api.openweathermap.org/data/2.5/forecast"

    def request_with_retries(url, params, retries=max_retries):
        """Helper: Retry request if connection fails."""
        attempt = 0
        while attempt < retries:
            try:
                response = requests.get(url, params=params, timeout=10)
                if response.status_code == 401:
                    raise ValueError("Invalid API key. Please check your OpenWeatherMap API key.")
                if response.status_code == 404:
                    raise ValueError(f"Location '{location}' not found. Please check the location name.")
                response.raise_for_status()
                return response.json()
            except requests.exceptions.RequestException as e:
                attempt += 1
                if attempt >= retries:
                    raise ConnectionError(f"Failed to connect after {retries} attempts: {e}")
                print(f"[Warning] Attempt {attempt} failed: {e}. Retrying...")
                time.sleep(2)

    # Validate forecast_days parameter
    if not isinstance(forecast_days, int) or forecast_days < 0 or forecast_days > 5:
        raise ValueError("forecast_days must be an integer between 0 and 5.")

    # Fetch current weather
    params = {"q": location, "appid": API_KEY, "units": units}
    current_data = request_with_retries(CURRENT_URL, params)

    if current_data.get("cod") != 200:
        error_message = current_data.get("message", "Unknown error")
        if "invalid api key" in error_message.lower():
            raise ValueError("Invalid API key. Please check your API key in OpenWeatherMap.")
        elif "city not found" in error_message.lower():
            raise ValueError(f"Location '{location}' not found. Please check the spelling.")
        else:
            raise ValueError(f"Error from API: {error_message}")

    current_weather = {
        "temperature": current_data["main"]["temp"],
        "humidity": current_data["main"]["humidity"],
        "description": current_data["weather"][0]["description"].capitalize(),
        "wind_speed": current_data["wind"]["speed"],
    }

    weather_output = {
        "location": f"{current_data.get('name')}, {current_data.get('sys', {}).get('country')}",
        "current": current_weather,
        "forecast": [],
        "summary": f"Current weather in {current_data.get('name')}: {current_weather['description']}, "
                   f"{current_weather['temperature']}Â° with {current_weather['humidity']}% humidity."
    }

    # Fetch forecast if requested
    if forecast_days > 0:
        forecast_params = {"q": location, "appid": API_KEY, "units": units}
        forecast_data = request_with_retries(FORECAST_URL, forecast_params)

        if forecast_data.get("cod") != "200":
            error_message = forecast_data.get("message", "Unknown error")
            raise ValueError(f"Forecast error: {error_message}")

        daily_forecast = {}
        for entry in forecast_data["list"]:
            date = entry["dt_txt"].split(" ")[0]
            if date not in daily_forecast:
                daily_forecast[date] = {
                    "temperature_min": entry["main"]["temp_min"],
                    "temperature_max": entry["main"]["temp_max"],
                    "description": entry["weather"][0]["description"].capitalize()
                }
            else:
                daily_forecast[date]["temperature_min"] = min(daily_forecast[date]["temperature_min"], entry["main"]["temp_min"])
                daily_forecast[date]["temperature_max"] = max(daily_forecast[date]["temperature_max"], entry["main"]["temp_max"])

        sorted_dates = sorted(daily_forecast.keys())
        weather_output["forecast"] = [
            {"date": d, **daily_forecast[d]} for d in sorted_dates[:forecast_days]
        ]

        weather_output["summary"] += f" Forecast available for next {forecast_days} day(s)."

    return weather_output
ðŸ”¹ Example Usage with Error Messages
try:
    weather = fetch_weather_data("InvalidCityName", units="metric", forecast_days=2)
    print(weather["summary"])
    print("Current:", weather["current"])
    if weather["forecast"]:
        print("Forecast:")
        for day in weather["forecast"]:
            print(day)
except ValueError as ve:
    print(f"[ValueError] {ve}")
except ConnectionError as ce:
    print(f"[ConnectionError] {ce}")
except Exception as e:
    print(f"[Error] {e}")

ðŸ”¹ Whatâ€™s Improved

1. Invalid API key detection â€” gives clear "Invalid API key" error.

2. Invalid location detection â€” gives clear "Location not found" error.

3. Connection retries â€” with warning and retry mechanism.

4. Detailed error messages â€” differentiates between API key, location, or other issues.
